<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>woongLog</title>
    <description>这里是 @woong黄玄 的个人博客，与你一起发现更大的世界 | 要做一个有 swag 的程序员</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 07 Mar 2024 18:12:39 +0900</pubDate>
    <lastBuildDate>Thu, 07 Mar 2024 18:12:39 +0900</lastBuildDate>
    <generator>Jekyll v4.3.2</generator>
    
      <item>
        <title>AWS Services(2)</title>
        <description>&lt;p&gt;&lt;strong&gt;Amazon EventBridge&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;애플리케이션 요소를 연결하는 이벤트 기반 서버리스 서비스&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;SES(Simple Email Service)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;SMTP(Simple Mail Transfer Protocol)방식과 API방식으로 이메일을 수신&amp;amp;발신&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;SNS(Simple notifications service)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;A2A, A2p 방식으로 알림을 전송&lt;/li&gt;
  &lt;li&gt;A2A: 분산된 시스템, 마이크로서비스 및 이벤트중심의 서버리스 애플리케이션 간 처리량이 많은 푸시 기반 다대다 메시징&lt;/li&gt;
  &lt;li&gt;A2P: SMS 텍스트, 푸시 알림, 이메일을 통한 메시지 전송&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;EventBridge&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Amazon CloudWatch Events기능 기반 상태 변화(이벤트) 감지&lt;/li&gt;
  &lt;li&gt;메일 전송, 인증서 감지 등에 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Amazon FSx&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Windows Server에 구축되는 완전관리형 파일 스토리지&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;SFTP(SSH File Transfer Protocol)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;암호화를 통한 파일 저장&amp;amp;업로드에 사용되는 전송 프로토콜&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;DataSync&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;온프레미스(On-premise)와 AWS 스토리지 서비스 사이 데이터 마이그레이션을 자동화/가속화하는 서비스&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;**AWS Firewall Manager **&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;AWS shield advanced의 속성, DDos 탐지 강화&lt;/li&gt;
  &lt;li&gt;SQL Injection, XSS 공격 등 방어&lt;/li&gt;
  &lt;li&gt;Region이 나누어져 있을 경우 일시 중앙에서 생성&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;SQS(Simple Queue Service)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;서비스가 커질수록 여러 서버에서 처리하게 되면서, 작업을 분리 할 때 등의 메시지를 주고받을 때 사용하는 서비스&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;오리진 액세스 제한&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;원본 액세스 제어(OAC), 원본 액세스 ID(OAI) 제공&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Amazon Athena&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;표준 SQL을 사용하여 S3의 데이터를 분석하는 대화형 쿼리 서비스&lt;/li&gt;
  &lt;li&gt;서버리스 서비스이므로 일회성 쿼리에 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Amazon QuickSight&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Amazon의 셀프 서비스 시각화 인텔리전스(BI) 도구&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Amazon MSK(Amazon Managed Streaming for Apache Kafka)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;완전관리형 Kafka를 통한 실시간 스트리밍 데이터 처리 서비스&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/woongaa1/post/eb0ad643-aba9-4930-921f-d30dd1df062e/image.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 07 Mar 2024 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2024/03/07/AWSwords_2/</link>
        <guid isPermaLink="true">http://localhost:4000/2024/03/07/AWSwords_2/</guid>
        
        <category>Cloud</category>
        
        <category>AWS</category>
        
        
      </item>
    
      <item>
        <title>AWS Services(1) (feat. network)</title>
        <description>&lt;h1 id=&quot;network&quot;&gt;Network&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;NAT&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;네트워크 트래픽을 패킷을 수정함으로써 포트 및 주소 등을 기록&lt;/li&gt;
  &lt;li&gt;프라이빗 서브넷에 대한 인터넷 엑세스를 활성화하는 등에 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;aws-services&quot;&gt;AWS Services&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Region&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;물리적으로 떨어진 지역에서의 여러개의 클라우드 인프라&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Availabilty Zone&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;리전들이 모여 구성하는 데이터 센터&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Edge Location&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;CDN(Content Delivery Network)을 이루는 캐시 서버&lt;/li&gt;
  &lt;li&gt;‘리전 에지 캐시’를 통해 데이터 속도 개선&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;EC2(Elastic Compute Cloud)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;컴퓨터 리소스에 대해 전반적 관리를 도와주는 가상 서버&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Lambda&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;특정한 이벤트를 통해 입력 인자가 발생하면 연산 과정으로 출력 인자를 바꾸는 이벤트 기반의 컴퓨팅 서비스&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;ECS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;AWS에서 제공하는 도커 컨테이너 서비스&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Lightsail&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;완전 관리형 가상 서버 서비스&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Beanstalk&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;EC2의 설정을 쉽게 돕는 서비스&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;S3&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;서비스 운영시 생성되는 이미지, 동영상, 오디오 파일등을 저장하는 스토리지 서비스&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Glacier&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;사용 빈도가 낮을 때(예: 백업 데이터) 사용하기 좋은 스토리지&lt;/li&gt;
  &lt;li&gt;저렴하지만 트래픽 요금이 높다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Storage Gateway&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;기존의 on-premise 환경과 AWS를 연결해주는 게이트웨이 서비스&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;EBS(Elastic Block Storage)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;EC2와 연결할 수 있는 저장장치 서비스&lt;/li&gt;
  &lt;li&gt;EC2의 하드디스크, SSD 스냅샷을 통해 언제든 EC2를 백업&amp;amp;복원 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;RDS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;관계형 데이터베이스(RDBMS)를 구축하는 서비스&lt;/li&gt;
  &lt;li&gt;SSD영역에서 입출력이 수행&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;DinamoDB&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;No-SQL 기반의 완전 관리형 데이터베이스&lt;/li&gt;
  &lt;li&gt;SSD영역에서 입출력이 수행&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Elasticcache&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;메모리에 데이터를 저장하여 빠르게 입출력이 가능한 데이터베이스&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Red Shift&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;완전 관리형 SQL 데이터 웨어하우스로써 대용량의 정형 데이터를 처리하는데 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;VPC(Virtual Private Cloud)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;가상 네트워크망 구축 지원 서비스&lt;/li&gt;
  &lt;li&gt;서비스 보안 수준을 결정하거나 적합한 권한이 있는 사용자들만 접속할 수 있도록 관리&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Route53&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;AWS의 DNS(Domain Name System)서비스&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;CloudFront&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;AWS의 클라우드 CDN서비스로 에지 로케이션 서버를 이용하여 콘텐츠를 배포&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Polly&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;텍스트를 음성으로 바꾸는(TTS) 음성 합성 서비스&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Lex&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;대화형 챗봇(Chatbot) 서비스&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Rekognition&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;이미지 인식&amp;amp;분석 서비스&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;QuickSight&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;태블로(Tableau)와 같이 데이터를 시각화하는 서비스&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Athena&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;서버리스 기반 SQL 쿼리 서비스&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;CloudSearch&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;완전 관리형 검색 서비스&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;EMR(Amazon Elastic MapReduce)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;빅데이터 분석 플랫폼인 하둡 프레임워크를 연동하여 사용할 수 있는 서비스&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Kinesis&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;실시간 데이터 처리를 위한 서비스&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 06 Mar 2024 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2024/03/06/AWSwords/</link>
        <guid isPermaLink="true">http://localhost:4000/2024/03/06/AWSwords/</guid>
        
        <category>Cloud</category>
        
        <category>Network</category>
        
        <category>AWS</category>
        
        
      </item>
    
      <item>
        <title>SSE 방식을 이용한 알림 구현</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;프로젝트에서 사용했던 SSE 방식에 대해&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;개요&quot;&gt;개요&lt;/h2&gt;
&lt;p&gt;알림 구현에는 크게 4가지 방식이 있다.&lt;/p&gt;

&lt;h3 id=&quot;폴링polling&quot;&gt;폴링(Polling)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;일정 시간마다 Client에서 Server로 요청을 보내고 응답을 받는 방식&lt;/li&gt;
  &lt;li&gt;응답해줄 데이터가 없어도 응답을 받음&lt;/li&gt;
  &lt;li&gt;지속적으로 request를 날림으로써 비용 부담 및 서버에 부하를 줄 수 있음
&lt;img src=&quot;https://velog.velcdn.com/images/woongaa1/post/119c4231-3077-4528-8e7c-4b83ce622220/image.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;롱-폴링long-polling&quot;&gt;롱 폴링(Long Polling)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;긴 connection을 열어두고, 이벤트가 발생했을때 Request를 보냄&lt;/li&gt;
  &lt;li&gt;응답해줄 데이터가 없으면 데이터가 생길때까지 기다림&lt;/li&gt;
  &lt;li&gt;connection 간격이 좁으면 Polling 방식과 큰 차이가 없음
&lt;img src=&quot;https://velog.velcdn.com/images/woongaa1/post/81491857-b22f-41a5-9be3-6e6109891178/image.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;웹소켓websocket&quot;&gt;웹소켓(WebSocket)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;양방향 통신으로써 Client, Server 간 Handshaking 방식으로 접속 후 통신&lt;/li&gt;
  &lt;li&gt;연결 후 계속 connection을 유지하므로 불필요한 비용 발생할 수 있음
&lt;img src=&quot;https://velog.velcdn.com/images/woongaa1/post/79f24b0b-b0bb-4246-9d98-a559bd8bc111/image.png&quot; alt=&quot;&quot; /&gt;
    &lt;h3 id=&quot;sseserver-sent-events&quot;&gt;SSE(Server-Sent-Events)&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;Client가 Server에 구독 요청을 보내면, Server에서 이벤트가 발생할 때마다 Response를 보냄&lt;/li&gt;
  &lt;li&gt;Server에서 Client로만 이벤트를 보내는 단방향 통신&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/woongaa1/post/d200c868-0596-4913-8f15-c636e05c83c5/image.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;우리는 사용자 알림에 대해서 기능을 구현할 예정이었기 때문에, SSE 방식을 통해서 알림을 구현하기로 했다.&lt;/p&gt;

&lt;h2 id=&quot;구현&quot;&gt;구현&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Emitter&lt;/code&gt;란?
SseEmitter 라는 SSE 통신을 위한 구현체를 제공받기 위해 사용&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;React(Client)&lt;/code&gt;에서 SSE응답을 받기 위한 방법
token을 사용하지 않을 때: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EventSource&lt;/code&gt;
token을 사용할 때: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EventSourcePolyfill&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;우리는 사용자 인증/인가를 JWT를 사용하여 구현하였기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EventSourcePolyfill&lt;/code&gt;을 사용하게 되었다.&lt;/p&gt;

&lt;h3 id=&quot;1-sseemitters-클래스&quot;&gt;1. SseEmitters 클래스&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Slf4j
@Getter
@Component
@RequiredArgsConstructor
public class SseEmitters {
    private final ConcurrentHashMap&amp;lt;String, SseEmitter&amp;gt; emitters = new ConcurrentHashMap&amp;lt;&amp;gt;();

    public SseEmitter add(String id, SseEmitter emitter) {
        emitters.put(id, emitter);
        log.info(&quot;new emitter added: {}&quot;, emitter);
        log.info(&quot;emitter list size: {}&quot;, emitters.size());

        return emitter;
    }

    public Map&amp;lt;String, SseEmitter&amp;gt; findEmitter(String id){
        return emitters.entrySet().stream()
                .filter(entry -&amp;gt; entry.getKey().startsWith(id))
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
    }

    public void delete(String id) {
        emitters.remove(id);
    }
}


&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;이벤트를 관리하는 SseEmitter, ConcurrentHashMap을 통해서 여러 스레드에서 동시에 접근해도 데이터를 처리할 수 있도록 함&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-notificationcontroller-클래스&quot;&gt;2. NotificationController 클래스&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Slf4j
@RestController
@RequiredArgsConstructor
@RequestMapping(&quot;/api/notification&quot;)
public class NotificationController {
    private final JWTUtil jwtUtil;
    private final NotificationService notificationService;

    // sse 연결
    @GetMapping(value = &quot;/subscribe/{userId}&quot;, produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public ResponseEntity&amp;lt;SseEmitter&amp;gt; subscribe(@PathVariable Long userId,
                                                @RequestHeader(value = &quot;lastEventId&quot;, required = false, defaultValue = &quot;&quot;) String lastEventId,
                                                HttpServletResponse response){
        log.info(lastEventId);
        return new ResponseEntity&amp;lt;&amp;gt;(notificationService.subscribe(userId, response), HttpStatus.OK);
    }

    // 유저 별 알림 조회
    @GetMapping(&quot;/{userId}&quot;)
    public ResponseEntity&amp;lt;List&amp;lt;Notification&amp;gt;&amp;gt; getUserNotifications(@PathVariable Long userId){
        List&amp;lt;Notification&amp;gt; notifications = notificationService.getUserNotifications(userId);
        return new ResponseEntity&amp;lt;&amp;gt; (notifications, HttpStatus.OK);
    }


&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;클라이언트 Header에 알림 모달이 위치해있고, 유저가 로그인해서 메인페이지에 접속하게 되면 Header를 통해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/api/notification/subscribe/{userId}&lt;/code&gt;에 구독 요청을 보낸다.&lt;/li&gt;
  &lt;li&gt;알림에는 아이디가 존재하는데, 통신 간에 누락 된 알림을 테스트하기 위해 lastEventId를 사용했다.&lt;/li&gt;
  &lt;li&gt;MediaType.TEXT_EVENT_STREAM_VALUE는 SSE를 지원하는 텍스트 형식을 나타낸다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-notificationservice-클래스&quot;&gt;3. NotificationService 클래스&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@Slf4j
@Service
@RequiredArgsConstructor
public class NotificationService {
    private final SseEmitters sseEmitters;
    private final NotificationRepository notificationRepository;
    // timeout 시간 설정
    private static final long TIMEOUT = 60 * 1000L;

    public SseEmitter subscribe(Long userId, HttpServletResponse response) {
        // 기존의 연결 종료
        String existingId = userId + &quot;_&quot;;
        Map&amp;lt;String, SseEmitter&amp;gt; existingEmitters = sseEmitters.findEmitter(existingId);
        existingEmitters.forEach((key, emitter) -&amp;gt; {
            emitter.complete();
            sseEmitters.delete(key);
        });

        // 새 연결 생성
        SseEmitter emitter = new SseEmitter(TIMEOUT);
        String id = userId + &quot;_&quot; + System.currentTimeMillis();
        sseEmitters.add(id, emitter);

        // NGINX PROXY 에서의 필요 설정 불필요한 버퍼링방지
        response.setHeader(&quot;X-Accel-Buffering&quot;, &quot;no&quot;);

        Map&amp;lt;String, Object&amp;gt; testContent = new HashMap&amp;lt;&amp;gt;();
        testContent.put(&quot;content&quot;, &quot;connected!&quot;);
        sendToClient(emitter, &quot;test&quot;, id, testContent);

        // 타임아웃 시 emitter 만료
        emitter.onTimeout(() -&amp;gt; {
            log.info(&quot;onTimeout callback&quot;);
            emitter.complete();
            sseEmitters.delete(id);
        });

		// 에러 발생
        emitter.onError(throwable -&amp;gt; {
            log.error(&quot;[sse] SseEmitters 파일 add 메서드 : {}&quot;, throwable.getMessage());
            emitter.complete();
            sseEmitters.delete(id);
        });

		//클라이언트와의 연결이 끊어졌을 때
        emitter.onCompletion(() -&amp;gt; {
            log.info(&quot;onCompletion callback&quot;);
            sseEmitters.delete(id);
        });

        return emitter;
    }


    private void sendToClient(SseEmitter emitter, String name, String id, Object data) {
        try {
            emitter.send(SseEmitter.event()
                    .id(id)
                    .name(name)
                    .data(data));
        } catch (IOException exception) {
            sseEmitters.delete(id);
            throw new RuntimeException(&quot;연결 오류!&quot;);
        }
    }

    @Transactional
    public void send(SendNotificationEvent noti) {
        Notification notification = notificationRepository.save(Notification.create(noti));
        log.info(&quot;저장됨&quot;);

        String receiverId = noti.getReceiver() + &quot;_&quot;;
        log.info(receiverId);

        // 해당 회원의 emitter 모두 찾아서 이벤트 전송
        Map&amp;lt;String, SseEmitter&amp;gt; emitters = sseEmitters.findEmitter(receiverId);
        log.info(emitters.entrySet().toString());

        emitters.forEach(
            (key, emitter) -&amp;gt; {
                sendToClient(emitter, noti.getName(), noti.getEventId(), notification);
                log.info(&quot;알림 전송 완료&quot;);
            }
        );
    }

    // 유저 별 알림 조회
    public List&amp;lt;Notification&amp;gt; getUserNotifications(Long userId) {
        return notificationRepository.findByReceiverOrderByNotificationCreatedDateDesc(userId);
    }

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;구독 요청이 들어왔을 때, 새로운 Emitter를 생성하고 더미 데이터를 보낸다. 기존 연결이 있다면 제거하고 새로운 Emitter를 생성한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;추가적으로, 읽지 않은 알림 및 전체 알림 조회/삭제 기능을 위해서 알림에 대한 Entity와 Repository를 생성해줬다.&lt;/p&gt;

&lt;h3 id=&quot;-클라이언트에서-구독-요청--응답-읽기&quot;&gt;(+) 클라이언트에서 구독 요청 &amp;amp; 응답 읽기&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;	// sse 연결 선언
    useEffect(() =&amp;gt; {
        // 마운트 시 로그인 상태 + sse 연결이 안 된 상태면 연결
        if (token &amp;amp;&amp;amp; !eventSource) {
            subscribe();
        }

        // 언마운트 시 sse 연결 종료
        return () =&amp;gt; {
            if (eventSource) {
                eventSource.close();
                console.log(&quot;연결 종료&quot;);
                setEventSource(null);
            }
        }
    },[eventSource, token])
    
    // sse 연결 시작
    const subscribe = async () =&amp;gt; {
        console.log(&quot;연결 시작&quot;);
        const source = new EventSourcePolyfill(
            `${notifyApi}/subscribe/` + userId,
            {
            headers: {
                Authorization: `Bearer ${token}`,
                lastEventId: lastEventId,
            },
            heartbeatTimeout: 600000,
            }
        );
        
        // mileage 관련 알림 받아옴
        source.addEventListener(&quot;mileage&quot;, (e) =&amp;gt; {
            setLastEventId(e.lastEventId);
            console.log(lastEventId);
            const data = JSON.parse(e.data);
            console.log(data);
            toast(data.content);
            setNotifications((prevNotifications) =&amp;gt; [data, ...prevNotifications]);
            console.log(notifications);
            setUnreadCount((prevCount) =&amp;gt; prevCount + 1);
        });
	}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;연결 이펙트에 대한 함수를 선언하고, Server에서 보내는 알림에 대해 setNotifications useState에 인자로 넣어준다.&lt;/p&gt;

&lt;h2 id=&quot;trouble-shooting&quot;&gt;Trouble Shooting&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;프로젝트에서 WebServer로 nginx를 사용했는데, nginx는 WAS로 HTTP/1.0을 사용하고 Connection: close 헤더를 사용하기 때문에 지속적으로 연결이 안돼서 SSE가 작동하지 않는다.
이에 대한 설정으로 nginx.conf에 추가해준다.
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;proxy_set_header Connection &apos;&apos;;
proxy_http_version 1.1;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;open-in-view를 false로 설정하여 요청이 트랜잭션이 처리되는 동안에만 데이터베이스 연결을 열어준다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 22 Feb 2024 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2024/02/22/sse/</link>
        <guid isPermaLink="true">http://localhost:4000/2024/02/22/sse/</guid>
        
        <category>Spring Boot</category>
        
        <category>SSE</category>
        
        
      </item>
    
      <item>
        <title>우리 팀에서 사용한 Git Branch 전략</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Github로 협업하는 과정에서 사용한 우리 팀의 Git-Branch 전략&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;branch&quot;&gt;Branch&lt;/h2&gt;
&lt;p&gt;브랜치는 용도에 맞게 &lt;strong&gt;master(main), develop, feature, release, hotfix&lt;/strong&gt; 브랜치를 분리해서 사용한다.&lt;/p&gt;

&lt;p&gt;메인 브랜치: &lt;strong&gt;master, develop&lt;/strong&gt;
보조 브랜치: &lt;strong&gt;feature, release, hotfix&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;개발기간이 1달 남짓되는 짧은 기간이었기 때문에, 99% develop, feature 브랜치를 사용했다.&lt;/p&gt;

&lt;p&gt;먼저 사진으로 보면 다음과 같다.
&lt;img src=&quot;https://velog.velcdn.com/images/woongaa1/post/76e9f57a-6ebf-489c-a066-d08650231ef9/image.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Git Flow 전략을 사용했는데, 각 과정에 대해 자세히 알아보도록 하자.&lt;/p&gt;

&lt;h2 id=&quot;1-이슈-생성&quot;&gt;1. 이슈 생성&lt;/h2&gt;

&lt;p&gt;진행해야 될 작업에 대해서 Issue를 생성한다.
Settings -&amp;gt; Issues &amp;gt; Set up templates 에서 템플릿을 생성할 수 있다.&lt;/p&gt;

&lt;p&gt;다음과 같이 작성할 수 있다.
&lt;img src=&quot;https://velog.velcdn.com/images/woongaa1/post/7ef06c7b-02b5-4b8f-9129-9967ab6fc512/image.png&quot; alt=&quot;&quot; /&gt; Assignees: 이 작업의 담당자를 설정한다.
Labels: 작업의 특징에 대해 설정한다. ( Labels -&amp;gt; New Labels 로 새로 생성할 수 있다.)&lt;/p&gt;

&lt;h2 id=&quot;2-브랜치-생성&quot;&gt;2. 브랜치 생성&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/woongaa1/post/fb409af9-6f31-4a7a-941b-e300b4bd2a71/image.png&quot; alt=&quot;&quot; /&gt; 하단의 Create a branch 를 통해서 브랜치를 생성한다.
기능 개발할 브랜치기 때문에, feature로 만들 수 있도록 하고, (#이슈번호)를 남기는 형태로 생성한다.&lt;/p&gt;

&lt;h2 id=&quot;3-작업&quot;&gt;3. 작업&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/woongaa1/post/cc759556-ee54-4917-b70b-734b27aa585c/image.png&quot; alt=&quot;&quot; /&gt;
이제, 커밋 메시지에 (#이슈번호)를 적어주게 되면 해당 이슈에 기록이 남는다.&lt;/p&gt;

&lt;p&gt;작업을 완료했으면 tasks를 체크해줄 수 있도록 한다.
&lt;img src=&quot;https://velog.velcdn.com/images/woongaa1/post/bffc7d6c-945e-4689-9520-7f27247a556e/image.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;4-prpull-request&quot;&gt;4. PR(Pull Request)&lt;/h2&gt;
&lt;p&gt;작업이 다 완료되면, PR을 생성한다.
이 때, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-closed #(이슈번호)&lt;/code&gt; 를 통해서 병합이 되었을 때 자동으로 이슈가 닫히도록 한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;이렇게 이슈를 통해서 작업을 진행한 결과 사진이다.
&lt;img src=&quot;https://velog.velcdn.com/images/woongaa1/post/7ad8d5dd-5caf-41a8-8ea7-5c295df0b834/image.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;라벨을 통해서 내가 한 작업을 볼 수도 있고, 커밋 타입별 작업을 볼 수 있어서 편리하다.
&lt;img src=&quot;https://velog.velcdn.com/images/woongaa1/post/4046504d-082d-4a13-8fdd-2c26159d8a67/image.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;5-create-release&quot;&gt;5. Create Release&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/woongaa1/post/9c4eb4a9-a23a-42d3-be1b-da2796f55857/image.png&quot; alt=&quot;&quot; /&gt;
모든 작업이 종료된 후에는, Releases를 만들어 배포할 수 있도록 했다.&lt;/p&gt;

&lt;p&gt;진행했던 Issue와 작업했던 member를 적어주고, 태그를 생성해 준다.&lt;/p&gt;

&lt;p&gt;릴리즈 태그를 통해서 배포할 것이기 때문에,
우리 팀에서 CI/CD에 사용한 Jenkins에서
&lt;img src=&quot;https://velog.velcdn.com/images/woongaa1/post/62e9a085-3c34-4729-b835-b40e43693354/image.png&quot; alt=&quot;&quot; /&gt; Brnach Specifier (blank for ‘any’) 부분을
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*/master&lt;/code&gt; 에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tags/v1.0.0&lt;/code&gt; 으로 적어주도록 한다.&lt;/p&gt;

&lt;h2 id=&quot;마치며&quot;&gt;마치며&lt;/h2&gt;
&lt;p&gt;이슈를 통한 간단한 Github Branch 전략을 정리해 보았다.
Github Actions, Jira 등 협업 전략을 효율적으로 사용하는 많은 방법이 있지만,
시간 관계상 빠르게 전략을 정해야 했기 때문에, 더 나은 방법에 대해서는 차차 알아가보도록 하려고 한다.&lt;/p&gt;
</description>
        <pubDate>Thu, 22 Feb 2024 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2024/02/22/git/</link>
        <guid isPermaLink="true">http://localhost:4000/2024/02/22/git/</guid>
        
        <category>Git</category>
        
        <category>Git-Flow</category>
        
        
      </item>
    
  </channel>
</rss>
