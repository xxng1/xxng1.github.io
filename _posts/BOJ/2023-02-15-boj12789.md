---
title:  "[12789] 도키도키 간식드리미"
excerpt: "BOJ_C++"

categories:
  - BOJ
tags:
  - [Algorithm, C++]

toc: true
toc_sticky: false
 
date: 2023-02-15
last_modified_at: 2023-02-15
sidebar_main: true

---
<!--
문제 🔍
풀이 🎯 ⭕ ❌
주의할 점 🚨
짚고갈 점 ✏️
기타 🔥🌝🪐🔔
-->
## 🔍 문제
> <https://www.acmicpc.net/problem/12789>
<div class="notice" markdown="1">
인하대학교 학생회에서는 중간, 기말고사 때마다 시험 공부에 지친 학우들을 위해 간식을 나눠주는 간식 드리미 행사를 실시한다. 승환이는 시험 기간이 될 때마다 간식을 받을 생각에 두근두근 설레서 시험 공부에 집중을 못 한다. 이번 중간고사에서도 역시 승환이는 설레는 가슴을 안고 간식을 받기 위해 미리 공지된 장소에 시간 맞춰 도착했다. 그런데 이게 무슨 날벼락인가! 그 곳에는 이미 모든 학생들이 모여있었고, 승환이는 마지막 번호표를 받게 되었다. 설상가상으로 몇몇 양심에 털이 난 학생들이 새치기를 거듭한 끝에 대기열의 순서마저 엉망이 되고 말았다. 간식을 나눠주고 있던 인규는 학우들의 터져 나오는 불만에 번호표 순서로만 간식을 줄 수 있다고 말했다. 

그제야 학생들이 순서대로 줄을 서려고 했지만 공간이 너무 협소해서 마음대로 이동할 수 없었다. 다행히도 대기열의 왼쪽에는 1열로 설 수 있는 공간이 존재하여 이 공간을 잘 이용하면 모두가 순서대로 간식을 받을 수 있을지도 모른다. 자칫 간식을 못 받게 될지도 모른다는 위기감을 느낀 승환이는 자신의 컴퓨터 알고리즘적 지식을 활용해 과연 모든 사람들이 순서대로 간식을 받을 수 있는지 확인하는 프로그램을 만들기로 했다. 만약 불가능 하다면 승환이는 이번 중간고사를 망치게 될 것 이고 가능하다면 힘을 얻어 중간고사를 잘 볼 수 있을지도 모른다.

사람들은 현재 1열로 줄을 서있고, 맨 앞의 사람만 이동이 가능하다. 인규는 번호표 순서대로만 통과할 수 있는 라인을 만들어 두었다. 이 라인과 대기열의 맨 앞 사람 사이에는 한 사람씩 1열이 들어갈 수 있는 공간이 있다. 현재 대기열의 사람들은 이 공간으로 올 수 있지만 반대는 불가능하다. 승환이를 도와 프로그램을 완성하라.

현재 간식 배부 공간을 그림으로 나타내면 다음과 같다.
-생략-
</div>

## 🎯 풀이
### 1. 첫 번째 풀이
그림을 보면 줄 서있는 곳에 5 4 1 3 2 순서로 있는데,

스택을 입력 받은 순서를 거꾸로 해야 줄 서있는 순서대로 된다
```cpp
#include <iostream>
#include <stack>

using namespace std;

int arr[1000];
int n, num, flag=1;

int main(){
    cin >> n;
    stack<int> s, h; // s = 줄 서있는 곳, h = 한 명씩만 설 수 있는 공간
    for(int i=0; i<n; i++){
        cin >> num;
        h.push(num);
    }

    for(int i=0; i<n; i++){ // 순서 거꾸로 하기.
        s.push(h.top());
        h.pop();
    }

    while(1){
        if(s.empty()==0){ // 스택 s부터 작업
            if(s.top()==flag){ // 값이 flag이면 제거
                s.pop();
                flag++;
            }
            else{ // 값이 flag가 아닐때
                if(h.empty()==0){ // 옮길 스택이 안비어있을때
                    if(h.top()==flag){ // h.top이 flag면
                        h.pop();
                        flag++;
                    }
                    else{ // 아니면 값 추가
                        h.push(s.top());
                        s.pop();
                    }
                }
                else{ // 비어있을때
                    h.push(s.top());
                    s.pop();
                }
            }            
        }
        else{ // 스택 s가 비어있을때
            if(h.empty()==0){ // 값이 비어있지않을때
                if(h.top()==flag){
                    h.pop();
                    flag++;
                }
                else{
                    cout << "Sad";
                    break;
                }
            }
            else{
                cout << "Nice";
                break;
            }
        }
    }
}
```
## ✏️ 회고
-
